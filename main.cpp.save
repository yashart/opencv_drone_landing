#include <opencv.hpp>
#include <highgui.hpp>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>
#include <thread>

int main(int argc, char* argv[])
{
    cv::Mat image;
    cv::Mat templ;
    const char* filename = argc >= 2 ? argv[1] : "circle-2.jpg";
//    image = cv::imread(filename,1);

    printf("[i] image: %s\n", filename);

    const char* filename2 = argc >= 3 ? argv[2] : "circle-1.jpg";
    printf("[i] template: %s\n", filename2);

    templ = cv::imread(filename2,1);

    cv::namedWindow("Match", CV_WINDOW_NORMAL);
    cv::VideoCapture cap(0);
    if (!cap.open(0)) {
        perror("bad cap");
    }
    while (1) {
        for (int i = 0; i < 30; i++) {
            cap.grab();
        }
        cap.retrieve(image);
        if(! image.data )
        {
            perror("Could not open or find the image");
            continue;

        cv::Mat res;
        int result_cols =  image.cols - templ.cols + 1;
        int result_rows = image.rows - templ.rows + 1;
        res.create( result_rows, result_cols, 0);
        cv::matchTemplate(image, templ, res, CV_TM_SQDIFF);

        double min_val, max_val;
        cv::Point min_loc, max_loc;

        cv::minMaxLoc(res, &min_val, &max_val, &min_loc, &max_loc, cv::Mat());

        double min_val_res = min_val;
        double max_val_res = max_val;
        cv::Point min_loc_res = min_loc;
        cv::Point max_loc_res = max_loc;
        cv::Mat resized_template;
        int templ_cols_res = templ.cols;
        int templ_rows_res = templ.rows;
        for (double scale = 1; scale > 0.1; scale -= 0.05) {
            int result_cols =  image.cols - templ.cols + 1;
            int result_rows = image.rows - templ.rows + 1;
            res.create( result_rows, result_cols, 0);
            cv::resize(templ, resized_template, cv::Size(), scale, scale, CV_INTER_LINEAR);

            cv::matchTemplate(image,
                              resized_template, res, CV_TM_SQDIFF);
            cv::minMaxLoc(res, &min_val_res, &max_val_res, &min_loc_res, &max_loc_res, cv::Mat());
            // For SQDIFF and SQDIFF_NORMED, the best matches are lower values. For all the other methods, the higher the better
            if (min_val_res < min_val) {
                min_val = min_val_res;
                max_val = max_val_res;
                min_loc = min_loc_res;
                max_loc = max_loc_res;
                templ_cols_res = templ.cols * scale;
                templ_rows_res = templ.rows * scale;
            }
        }
        cv::Mat img_display;
        image.copyTo( img_display );
        cv::rectangle(img_display, min_loc, cv::Point(min_loc.x + templ_cols_res, min_loc.y + templ_rows_res), cv::Scalar::all(0), 2, 8, 0);
        cv::imshow("Match", img_display);
        if( cv::waitKey(1) == 27 ) break;
    }

    //cvReleaseImage( &image );
    //cvReleaseImage( &templ );
    //cvReleaseImage( &res );
    cvDestroyAllWindows();
    return 0;
}
